use board::{
    index::{self, black, white},
    position_tables, weights,
};
use rand::Rng;
use rayon::prelude::*;
use std::io;

pub mod board {
    /**
    generated by
    https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type%20Something%20
    */
    pub const TITLE: &'static str = r"
 ______   ______     ______     __    __     __     __   __     ______     __        
/\__  _\ /\  ___\   /\  == \   /\ \-./  \   /\ \   /\ \-.\ \   /\  __ \   /\ \       
\/_/\ \/ \ \  __\   \ \  __<   \ \ \-./\ \  \ \ \  \ \ \-.  \  \ \  __ \  \ \ \____  
   \ \_\  \ \_____\  \ \_\ \_\  \ \_\ \ \_\  \ \_\  \ \_\\*\_\  \ \_\ \_\  \ \_____\ 
    \/_/   \/_____/   \/_/ /_/   \/_/  \/_/   \/_/   \/_/ \/_/   \/_/\/_/   \/_____/                                                                                    
 ______     __  __     ______     ______     ______                                  
/\  ___\   /\ \_\ \   /\  ___\   /\  ___\   /\  ___\                                 
\ \ \____  \ \  __ \  \ \  __\   \ \___  \  \ \___  \                                
 \ \_____\  \ \_\ \_\  \ \_____\  \/\_____\  \/\_____\                               
  \/_____/   \/_/\/_/   \/_____/   \/_____/   \/_____/";
    pub const CREDITS: &'static str = r"
    Created by: Peter Schaefer
    Inspired by: Sebastian Lague, @SebastianLague on YouTube";
    pub const RANKS: usize = 8;
    pub const FILES: usize = 8;
    pub const TOP_BORDER: &'static str = r" .-.================================================================================================.-.";
    pub const BOTTOM_BORDER: &'static str = r" '-'=========[a]=========[b]=========[c]=========[d]=========[e]=========[f]=========[g]=========[h]'-'";
    pub const MOVE_PATTERN: &'static str = r"to";
    pub const LAYERS_PER_RANK: usize = 5;
    pub const MAX_SQUARE_INDEX: usize = 63;

    pub const FILE_A: u64 =
        0b_10000000_10000000_10000000_10000000_10000000_10000000_10000000_10000000;
    pub const FILE_B: u64 =
        0b_01000000_01000000_01000000_01000000_01000000_01000000_01000000_01000000;
    pub const FILE_G: u64 =
        0b_00000010_00000010_00000010_00000010_00000010_00000010_00000010_00000010;
    pub const FILE_H: u64 =
        0b_00000001_00000001_00000001_00000001_00000001_00000001_00000001_00000001;
    pub const RANK_8: u64 =
        0b_11111111_00000000_00000000_00000000_00000000_00000000_00000000_00000000;
    pub const RANK_7: u64 =
        0b_00000000_11111111_00000000_00000000_00000000_00000000_00000000_00000000;
    pub const RANK_2: u64 =
        0b_00000000_00000000_00000000_00000000_00000000_00000000_11111111_00000000;
    pub const RANK_1: u64 =
        0b_00000000_00000000_00000000_00000000_00000000_00000000_00000000_11111111;

    pub mod weights {
        pub const PAWN: u32 = 100;
        pub const KNIGHT: u32 = 320;
        pub const BISHOP: u32 = 330;
        pub const ROOK: u32 = 500;
        pub const QUEEN: u32 = 900;
        pub const KING: u32 = 20_000;
    }

    /**
     * Source for the used positional Piece-Square Tables:
     * https://www.chessprogramming.org/Simplified_Evaluation_Function 
     */
    #[rustfmt::skip]
    pub mod position_tables {
        pub const PAWN: [isize; 64] = [
             0,  0,  0,  0,  0,  0,  0,  0, 
            50, 50, 50, 50, 50, 50, 50, 50, 
            10, 10, 20, 30, 30, 20, 10, 10,
             5,  5, 10, 25, 25, 10,  5,  5,
             0,  0,  0, 20, 20,  0,  0,  0,
             5, -5,-10,  0,  0,-10, -5,  5,
             5, 10, 10,-20,-20, 10, 10,  5,
             0,  0,  0,  0,  0,  0,  0,  0,
        ];

        pub const KNIGHT: [isize; 64] = [
            -50,-40,-30,-30,-30,-30,-40,-50,
            -40,-20,  0,  0,  0,  0,-20,-40,
            -30,  0, 10, 15, 15, 10,  0,-30,
            -30,  5, 15, 20, 20, 15,  5,-30,
            -30,  0, 15, 20, 20, 15,  0,-30,
            -30,  5, 10, 15, 15, 10,  5,-30,
            -40,-20,  0,  5,  5,  0,-20,-40,
            -50,-40,-30,-30,-30,-30,-40,-50,
        ];

        pub const BISHOP: [isize; 64] = [
            -20,-10,-10,-10,-10,-10,-10,-20,
            -10,  0,  0,  0,  0,  0,  0,-10,
            -10,  0,  5, 10, 10,  5,  0,-10,
            -10,  5,  5, 10, 10,  5,  5,-10,
            -10,  0, 10, 10, 10, 10,  0,-10,
            -10, 10, 10, 10, 10, 10, 10,-10,
            -10,  5,  0,  0,  0,  0,  5,-10,
            -20,-10,-10,-10,-10,-10,-10,-20,
        ];

        pub const ROOK: [isize; 64] = [
              0,  0,  0,  0,  0,  0,  0,  0,
              5, 10, 10, 10, 10, 10, 10,  5,
             -5,  0,  0,  0,  0,  0,  0, -5,
             -5,  0,  0,  0,  0,  0,  0, -5,
             -5,  0,  0,  0,  0,  0,  0, -5,
             -5,  0,  0,  0,  0,  0,  0, -5,
             -5,  0,  0,  0,  0,  0,  0, -5,
              0,  0,  0,  5,  5,  0,  0,  0
        ];

        pub const QUEEN: [isize; 64] = [
            -20,-10,-10, -5, -5,-10,-10,-20,
            -10,  0,  0,  0,  0,  0,  0,-10,
            -10,  0,  5,  5,  5,  5,  0,-10,
             -5,  0,  5,  5,  5,  5,  0, -5,
              0,  0,  5,  5,  5,  5,  0, -5,
            -10,  5,  5,  5,  5,  5,  0,-10,
            -10,  0,  5,  0,  0,  0,  0,-10,
            -20,-10,-10, -5, -5,-10,-10,-20
        ];

        pub const KING_MIDDLE: [isize; 64] = [
            -30,-40,-40,-50,-50,-40,-40,-30,
            -30,-40,-40,-50,-50,-40,-40,-30,
            -30,-40,-40,-50,-50,-40,-40,-30,
            -30,-40,-40,-50,-50,-40,-40,-30,
            -20,-30,-30,-40,-40,-30,-30,-20,
            -10,-20,-20,-20,-20,-20,-20,-10,
             20, 20,  0,  0,  0,  0, 20, 20,
             20, 30, 10,  0,  0, 10, 30, 20
        ];

        pub const KING_END: [isize; 64] = [
            -50,-40,-30,-20,-20,-30,-40,-50,
            -30,-20,-10,  0,  0,-10,-20,-30,
            -30,-10, 20, 30, 30, 20,-10,-30,
            -30,-10, 30, 40, 40, 30,-10,-30,
            -30,-10, 30, 40, 40, 30,-10,-30,
            -30,-10, 20, 30, 30, 20,-10,-30,
            -30,-30,  0,  0,  0,  0,-30,-30,
            -50,-30,-30,-30,-30,-30,-30,-50
        ];
    }

    pub mod index {
        pub mod black {
            pub const PAWN: usize = 0;
            pub const KNIGHT: usize = 1;
            pub const BISHOP: usize = 2;
            pub const ROOK: usize = 3;
            pub const QUEEN: usize = 4;
            pub const KING: usize = 5;
        }
        pub mod white {
            pub const PAWN: usize = 6;
            pub const KNIGHT: usize = 7;
            pub const BISHOP: usize = 8;
            pub const ROOK: usize = 9;
            pub const QUEEN: usize = 10;
            pub const KING: usize = 11;
        }
        pub const EMPTY: usize = 12;
    }
    #[rustfmt::skip]
    pub const PIECE: [[[&'static str; 13]; 5]; 2] = [
    [
        [r"::::::::::::",r"::::::::::::",r"::::::::::::",r"::::::::::::",r"::: _ww_ :::",r"::::\++/::::",r"::::::::::::",r"::::::::::::",r"::::::::::::",r"::::::::::::",r"::: _ww_ :::",r"::::\++/::::",r"::::::::::::"],
        [r"::::::::::::",r"::: __,,::::",r":::::<>:::::",r"::::UUUU::::",r"::: \  / :::",r"::::(  )::::",r"::::::::::::",r"::: __,, :::",r":::::<>:::::",r"::::UUUU::::",r"::: \@@/ :::",r"::::(@@)::::",r"::::::::::::"],
        [r":::::():::::",r":: L   \~ ::",r":::::/\:::::",r"::::|  |::::",r"::: |  | :::",r"::::|  |::::",r":::::():::::",r":: L@@@\~ ::",r":::::/\:::::",r"::: |@@| :::",r"::: |@@| :::",r"::::|@@|::::",r"::::::::::::"],
        [r":::::{}:::::",r":::: ) ( :::",r"::::\  /::::",r"::::|  |::::",r"::: /  \ :::",r"::::/  \::::",r":::: @@ ::::",r":::: )@( :::",r"::: \@@/ :::",r"::: |@@| :::",r"::: /@@\ :::",r"::::/@@\::::",r"::::::::::::"],
        [r"::::{__}::::",r":: {____} ::",r":::{____}:::",r":::{____}:::",r":: {____} ::",r":::{____}:::",r"::: {@@} :::",r":: {@@@@} ::",r":: {@@@@} ::",r":: {@@@@} ::",r":: {@@@@} ::",r":::{@@@@}:::",r"::::::::::::"],
        ],
    [
        [r"            ",r"            ",r"            ",r"            ",r"    _ww_    ",r"    \++/    ",r"            ",r"            ",r"            ",r"            ",r"    _ww_    ",r"    \++/    ",r"            "],
        [r"            ",r"    __,,    ",r"     <>     ",r"    UUUU    ",r"    \  /    ",r"    (  )    ",r"            ",r"    __,,    ",r"     <>     ",r"    UUUU    ",r"    \@@/    ",r"    (@@)    ",r"            "],
        [r"     ()     ",r"   L   \~   ",r"     /\     ",r"    |  |    ",r"    |  |    ",r"    |  |    ",r"     ()     ",r"   L@@@\~   ",r"     /\     ",r"    |@@|    ",r"    |@@|    ",r"    |@@|    ",r"            "],
        [r"     {}     ",r"     ) (    ",r"    \  /    ",r"    |  |    ",r"    /  \    ",r"    /  \    ",r"     @@     ",r"     )@(    ",r"    \@@/    ",r"    |@@|    ",r"    /@@\    ",r"    /@@\    ",r"            "],
        [r"    {__}    ",r"   {____}   ",r"   {____}   ",r"   {____}   ",r"   {____}   ",r"   {____}   ",r"    {@@}    ",r"   {@@@@}   ",r"   {@@@@}   ",r"   {@@@@}   ",r"   {@@@@}   ",r"   {@@@@}   ",r"            "],
    ],
];
}

pub mod bit_math {
    use crate::board;

    pub fn is_file_a(bit_piece: &u64) -> bool {
        bit_piece & board::FILE_A > 0
    }

    pub fn is_file_b(bit_piece: &u64) -> bool {
        bit_piece & board::FILE_B > 0
    }

    pub fn is_file_g(bit_piece: &u64) -> bool {
        bit_piece & board::FILE_G > 0
    }

    pub fn is_file_h(bit_piece: &u64) -> bool {
        bit_piece & board::FILE_H > 0
    }

    pub fn is_rank_8(bit_piece: &u64) -> bool {
        bit_piece & board::RANK_8 > 0
    }

    pub fn is_rank_7(bit_piece: &u64) -> bool {
        bit_piece & board::RANK_7 > 0
    }

    pub fn is_rank_2(bit_piece: &u64) -> bool {
        bit_piece & board::RANK_2 > 0
    }

    pub fn is_rank_1(bit_piece: &u64) -> bool {
        bit_piece & board::RANK_1 > 0
    }
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Move {
    pub start: u64,
    pub end: u64,
}

impl Move {
    pub fn new(start: &u64, end: &u64) -> Self {
        Self {
            start: *start,
            end: *end,
        }
    }
}

/**
 * Each board is stored as bitmaps of the pieces, since a board is 8x8 we use a u64.
 * The bit position corresponds to a place on the board:
 *   `-------------------------`
 * 8 | 63 62 61 60 59 58 57 56 |
 * 7 | 55 54 53 52 51 50 49 48 |
 * 6 | 47 46 45 44 43 42 41 40 |
 * 5 | 39 38 37 36 35 34 33 32 |
 * 4 | 31 30 29 28 27 26 25 24 |
 * 3 | 23 22 21 20 19 18 17 16 |
 * 2 | 15 14 13 12 11 10 09 08 |
 * 1 | 07 06 05 04 03 02 01 00 |
 *   `-------------------------`
 *      a  b  c  d  e  f  g  h
 */

#[derive(Clone, Copy)]
pub struct Chess {
    bit_boards: [u64; index::EMPTY],
    white_bits: u64,
    black_bits: u64,
    turn: u16,
    game_over: bool,
}

#[derive(Debug)]
struct NotFound;

impl Chess {
    /**
     * sets up the bit board for a default game of chess
     */
    pub fn new() -> Self {
        let mut s = Self {
            bit_boards: [
                0b_00000000_11111111_00000000_00000000_00000000_00000000_00000000_00000000, // black pawns
                0b_01000010_00000000_00000000_00000000_00000000_00000000_00000000_00000000, // black knights
                0b_00100100_00000000_00000000_00000000_00000000_00000000_00000000_00000000, // black bishops
                0b_10000001_00000000_00000000_00000000_00000000_00000000_00000000_00000000, // black rooks
                0b_00010000_00000000_00000000_00000000_00000000_00000000_00000000_00000000, // black queens
                0b_00001000_00000000_00000000_00000000_00000000_00000000_00000000_00000000, // black kings
                0b_00000000_00000000_00000000_00000000_00000000_00000000_11111111_00000000, // white pawns
                0b_00000000_00000000_00000000_00000000_00000000_00000000_00000000_01000010, // white knights
                0b_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00100100, // white bishops
                0b_00000000_00000000_00000000_00000000_00000000_00000000_00000000_10000001, // white rooks
                0b_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00010000, // white queens
                0b_00000000_00000000_00000000_00000000_00000000_00000000_00000000_00001000, // white kings
            ],
            white_bits: 0,
            black_bits: 0,
            turn: 0,
            game_over: false,
        };

        *s.update_black_bits().update_white_bits()
    }

    pub fn play(self: &mut Self) -> &mut Self {
        println!("{}\n{}\n\n", board::TITLE, board::CREDITS);
        println!("Would you like to play as black or white? ");
        let mut input = String::new();
        io::stdin()
            .read_line(&mut input)
            .expect("Failed to read input.");

        if input.to_ascii_lowercase().contains("black") {
            // make a random move for white, so the player can play as black
            let moves = self.get_legal_moves();
            self.move_piece(moves[rand::thread_rng().gen_range(0..moves.len())]);
        }

        loop {
            if self
                .clear_screen()
                .print_title()
                .print_board()
                .make_user_move()
                .game_over
            {
                break;
            }

            if self
                .clear_screen()
                .print_title()
                .print_board()
                .make_ai_move()
                .game_over
            {
                break;
            }
        }

        self.finish_game();
        io::stdin()
            .read_line(&mut input)
            .expect("Failed to read input.");

        self
    }

    /**
     * determines who won the game and congratulates them
     */
    fn finish_game(self: &mut Self) -> &mut Self {
        // the game ended because someone couldn't play a move, let's see if the other player has checkmate
        self.turn += 1;
        if self.get_legal_moves().into_iter().any(|mv| {
            mv.end == self.bit_boards[white::KING] || mv.end == self.bit_boards[black::KING]
        }) {
            // there was a checkmate!
            println!(
                "\nThe winner of this game is {}!",
                if self.turn % 2 == 0 { "WHITE" } else { "BLACK" }
            );
        } else {
            println!("\nThis game ends in a STALEMATE!");
        }

        self
    }

    /**
     * prints the title for the game
     */
    fn print_title(self: &mut Self) -> &mut Self {
        println!("{}\n{}\n\n", board::TITLE, board::CREDITS);
        self
    }

    /**
     * clears the screen
     */
    fn clear_screen(self: &mut Self) -> &mut Self {
        for _ in 0..50 {
            println!();
        }
        self
    }

    /**
     * makes an move using the ai chess engine, or marks the game as over
     */
    fn make_ai_move(self: &mut Self) -> &mut Self {
        println!("\nOpponent is thinking...");
        let mut moves = self.evaluate_legal_moves(5);

        if moves.len() == 0 {
            self.game_over = true;
            return self;
        }

        moves.sort_by(|(eval1, _), (eval2, _)| eval1.cmp(eval2));
        self.move_piece(moves[0].1)
    }

    /**
     * prompts the user for a legal move to make, and then makes that move
     */
    fn make_user_move(self: &mut Self) -> &mut Self {
        let possible_moves = self.get_legal_moves();
        if possible_moves.len() == 0 {
            self.game_over = true;
            return self;
        }

        self.move_piece(loop {
            let potential_move = self.get_user_move();
            if possible_moves.contains(&potential_move) {
                break potential_move;
            } else {
                println!("\nThat is not a legal move!");
            }
        })
    }

    fn get_user_move(self: &Self) -> Move {
        loop {
            println!("\nPlease input your move, use format `x1 to y2`:");
            let mut input = String::new();
            io::stdin()
                .read_line(&mut input)
                .expect("Failed to read input.");
            match Self::parse_user_move(input) {
                Ok(mv) => break mv,
                Err(_) => println!(
                    "Incorrect move format! Use format `x1 to y2`, for example `a1 to b2`."
                ),
            }
        }
    }

    /**
     * parses a users input and returns the corresponding moving is the input was valid
     */
    fn parse_user_move(input: String) -> Result<Move, ()> {
        let parts = input.trim().to_lowercase();
        let parts = parts
            .split(board::MOVE_PATTERN)
            .map(|input| input.trim())
            .collect::<Vec<_>>();

        if parts.len() != 2 {
            return Err(());
        }

        let start = Self::parse_coordinate(parts[0])?;
        let end = Self::parse_coordinate(parts[1])?;

        Ok(Move { start, end })
    }

    /**
     * turns a coordinate in the form x1 into a usize corresponding to the proper square on the board
     */
    fn parse_coordinate(input: &str) -> Result<u64, ()> {
        let mut input = input.chars();
        let file: usize = match input.next().unwrap_or('z') {
            'a' => 7,
            'b' => 6,
            'c' => 5,
            'd' => 4,
            'e' => 3,
            'f' => 2,
            'g' => 1,
            'h' => 0,
            _ => return Err(()),
        };

        let rank: i32 = match String::from(input.next().unwrap_or('z')).parse() {
            Ok(x) if x >= 1 && 8 >= x => x - 1,
            Ok(_) | Err(_) => return Err(()),
        };
        Ok(1 << (rank as usize * board::FILES + file))
    }

    /**
     * Evaluates a position, based on who's turn it currently is
     */
    pub fn evaluate(self: &Self) -> isize {
        let perspective = match self.turn % 2 {
            0 => 1,
            1 => -1,
            _ => unreachable!(),
        };

        if self.bit_boards[white::KING] == 0 {
            return (isize::MIN + 1) * perspective;
        } else if self.bit_boards[black::KING] == 0 {
            return isize::MAX * perspective;
        }

        (self.material_sum_white() as isize + self.positional_sum_white()
            - self.material_sum_black() as isize
            - self.positional_sum_black())
            * perspective
    }

    /**
     * sums up the material for white and returns the sum
     */
    fn material_sum_white(self: &Self) -> u32 {
        self.bit_boards[white::PAWN].count_ones() * weights::PAWN
            + self.bit_boards[white::KNIGHT].count_ones() * weights::KNIGHT
            + self.bit_boards[white::BISHOP].count_ones() * weights::BISHOP
            + self.bit_boards[white::ROOK].count_ones() * weights::ROOK
            + self.bit_boards[white::QUEEN].count_ones() * weights::QUEEN
            + self.bit_boards[white::KING].count_ones() * weights::KING
    }

    /**
     * sums up the material for black and returns the sum
     */
    fn material_sum_black(self: &Self) -> u32 {
        self.bit_boards[black::PAWN].count_ones() * weights::PAWN
            + self.bit_boards[black::KNIGHT].count_ones() * weights::KNIGHT
            + self.bit_boards[black::BISHOP].count_ones() * weights::BISHOP
            + self.bit_boards[black::ROOK].count_ones() * weights::ROOK
            + self.bit_boards[black::QUEEN].count_ones() * weights::QUEEN
            + self.bit_boards[black::KING].count_ones() * weights::KING
    }

    /**
     * evaluates the position of the board and gives it a score for white
     */
    fn positional_sum_white(self: &Self) -> isize {
        let mut sum = 0isize;
        let mut mask = 1u64;
        for i in 0..64 {
            // if there is no white piece here, just move on
            if mask & self.white_bits == 0 {
                mask <<= 1;
                continue;
            }

            if mask & self.bit_boards[white::PAWN] > 0 {
                sum += position_tables::PAWN[board::MAX_SQUARE_INDEX - i];
            } else if mask & self.bit_boards[white::KNIGHT] > 0 {
                sum += position_tables::KNIGHT[board::MAX_SQUARE_INDEX - i];
            } else if mask & self.bit_boards[white::BISHOP] > 0 {
                sum += position_tables::BISHOP[board::MAX_SQUARE_INDEX - i];
            } else if mask & self.bit_boards[white::ROOK] > 0 {
                sum += position_tables::ROOK[board::MAX_SQUARE_INDEX - i];
            } else if mask & self.bit_boards[white::QUEEN] > 0 {
                sum += position_tables::QUEEN[board::MAX_SQUARE_INDEX - i];
            } else if mask & self.bit_boards[white::KING] > 0 {
                if self.bit_boards[white::QUEEN] != 0 || self.bit_boards[black::QUEEN] != 0 {
                    sum += position_tables::KING_MIDDLE[board::MAX_SQUARE_INDEX - i];
                } else {
                    sum += position_tables::KING_END[board::MAX_SQUARE_INDEX - i];
                }
            }

            mask <<= 1;
        }

        sum
    }

    /**
     * evaluates the position of the board and gives it a score for black
     */
    fn positional_sum_black(self: &Self) -> isize {
        let mut sum = 0isize;
        let mut mask = 1u64;
        for i in 0..64 {
            // if there is no white piece here, just move on
            if mask & self.black_bits == 0 {
                mask <<= 1;
                continue;
            }

            if mask & self.bit_boards[black::PAWN] > 0 {
                sum += position_tables::PAWN[i];
            } else if mask & self.bit_boards[black::KNIGHT] > 0 {
                sum += position_tables::KNIGHT[i];
            } else if mask & self.bit_boards[black::BISHOP] > 0 {
                sum += position_tables::BISHOP[i];
            } else if mask & self.bit_boards[black::ROOK] > 0 {
                sum += position_tables::ROOK[i];
            } else if mask & self.bit_boards[black::QUEEN] > 0 {
                sum += position_tables::QUEEN[i];
            } else if mask & self.bit_boards[black::KING] > 0 {
                if self.bit_boards[white::QUEEN] != 0 || self.bit_boards[black::QUEEN] != 0 {
                    sum += position_tables::KING_MIDDLE[i];
                } else {
                    sum += position_tables::KING_END[i];
                }
            }

            mask <<= 1;
        }

        sum
    }

    /**
     * uses a minimax algorithm with alpha beta pruning to speed up the search
     * https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning
     */
    fn minimax(self: &Self, depth: u8, mut alpha: isize, beta: isize) -> isize {
        // run out of depth or game over
        if depth == 0 || self.bit_boards[white::KING] == 0 || self.bit_boards[black::KING] == 0 {
            return self.evaluate();
        }

        // for each move, see what the best opponent move is
        for bit_move in self.get_pseudo_moves() {
            // a good eval for out opponent is a bad eval for us
            let evaluation = -self
                .clone()
                .move_piece(bit_move)
                .minimax(depth - 1, -beta, -alpha);

            if evaluation >= beta {
                return beta;
            }

            alpha = alpha.max(evaluation);
        }

        alpha
    }

    /**
     * Goes through each move and gives it a score of how good it is.
     * 0 is neutral, white >0 is good, and <0 is bad
     */
    fn evaluate_legal_moves(self: &Self, depth: u8) -> Vec<(isize, Move)> {
        self.get_legal_moves()
            .par_iter()
            .map(|mv| {
                (
                    self.clone()
                        .move_piece(*mv)
                        .minimax(depth, isize::MIN + 1, isize::MAX),
                    mv.clone(),
                )
            })
            .collect()
    }

    /**
     * Gets the raw moves for each piece.
     * Does not *ensure* that they will all be legal, and sometimes need to be filtered.
     */
    fn get_pseudo_moves(self: &Self) -> Vec<Move> {
        if self.turn % 2 == 0 {
            self.get_white_moves()
        } else {
            self.get_black_moves()
        }
    }

    /**
     * Gets the legal moves for each piece
     */
    fn get_legal_moves(self: &Self) -> Vec<Move> {
        let king_index = if self.turn % 2 == 0 {
            white::KING
        } else {
            black::KING
        };

        let pseudo_moves = self.get_pseudo_moves();
        let mut legal_moves = Vec::<Move>::new();

        // for each move, make sure every possible response move cannot take the king
        for m in pseudo_moves {
            let mut hypothetical = self.clone();
            if !hypothetical
                .move_piece(m)
                .get_pseudo_moves()
                .into_iter()
                .any(|m| m.end == hypothetical.bit_boards[king_index])
            {
                legal_moves.push(m);
            }
        }

        legal_moves
    }

    /**
     * Gets the moves for all of the white pieces on the board
     */
    fn get_white_moves(self: &Self) -> Vec<Move> {
        let mut moves = Vec::<Move>::new();

        let mut bit_piece = 1u64;
        for _ in 0..u64::BITS {
            // if there is no white piece here, just move on
            if bit_piece & self.white_bits == 0 {
                bit_piece <<= 1;
                continue;
            }

            if bit_piece & self.bit_boards[white::PAWN] > 0 {
                moves.append(&mut self.get_white_pawn_moves(&bit_piece));
            } else if bit_piece & self.bit_boards[white::KNIGHT] > 0 {
                moves.append(&mut self.get_knight_moves(&bit_piece, &true));
            } else if bit_piece & self.bit_boards[white::BISHOP] > 0 {
                moves.append(&mut self.get_diagonal_moves(&bit_piece, &true));
            } else if bit_piece & self.bit_boards[white::ROOK] > 0 {
                moves.append(&mut self.get_cartesian_moves(&bit_piece, &true));
            } else if bit_piece & self.bit_boards[white::QUEEN] > 0 {
                moves.append(&mut self.get_cartesian_moves(&bit_piece, &true));
                moves.append(&mut self.get_diagonal_moves(&bit_piece, &true));
            } else {
                moves.append(&mut self.get_king_moves(&bit_piece, &true));
            }

            bit_piece <<= 1;
        }

        moves
    }

    /**
     * Gets the moves for all of the black pieces on the board
     */
    fn get_black_moves(self: &Self) -> Vec<Move> {
        let mut moves = Vec::<Move>::new();

        let mut bit_piece = 1u64;
        for _ in 0..u64::BITS {
            // if there is no white piece here, just move on
            if bit_piece & self.black_bits == 0 {
                bit_piece <<= 1;
                continue;
            }

            if bit_piece & self.bit_boards[black::PAWN] > 0 {
                moves.append(&mut self.get_black_pawn_moves(&bit_piece));
            } else if bit_piece & self.bit_boards[black::KNIGHT] > 0 {
                moves.append(&mut self.get_knight_moves(&bit_piece, &false));
            } else if bit_piece & self.bit_boards[black::BISHOP] > 0 {
                moves.append(&mut self.get_diagonal_moves(&bit_piece, &false));
            } else if bit_piece & self.bit_boards[black::ROOK] > 0 {
                moves.append(&mut self.get_cartesian_moves(&bit_piece, &false));
            } else if bit_piece & self.bit_boards[black::QUEEN] > 0 {
                moves.append(&mut self.get_cartesian_moves(&bit_piece, &false));
                moves.append(&mut self.get_diagonal_moves(&bit_piece, &false));
            } else {
                moves.append(&mut self.get_king_moves(&bit_piece, &false));
            }

            bit_piece <<= 1;
        }

        moves
    }

    /**
     * returns the move pairs for the bit_piece when moved as a rook
     */
    fn get_cartesian_moves(self: &Self, bit_piece: &u64, is_white: &bool) -> Vec<Move> {
        let mut moves = Vec::<Move>::new();

        moves.append(&mut self.get_marching_moves(
            |x| x.rotate_left(1),
            bit_math::is_file_h,
            &is_white,
            &bit_piece,
        ));
        moves.append(&mut self.get_marching_moves(
            |x| x.rotate_right(1),
            bit_math::is_file_a,
            &is_white,
            &bit_piece,
        ));
        moves.append(&mut self.get_marching_moves(
            |x| x.rotate_left(8),
            bit_math::is_rank_1,
            &is_white,
            &bit_piece,
        ));
        moves.append(&mut self.get_marching_moves(
            |x| x.rotate_right(8),
            bit_math::is_rank_8,
            &is_white,
            &bit_piece,
        ));

        moves
    }

    /**
     * returns the move pairs for the bit_piece when moved as a bishop
     */
    fn get_diagonal_moves(self: &Self, bit_piece: &u64, is_white: &bool) -> Vec<Move> {
        let mut moves = Vec::<Move>::new();

        moves.append(&mut self.get_marching_moves(
            |x| x.rotate_left(9),
            |x| bit_math::is_rank_1(x) || bit_math::is_file_h(x),
            &is_white,
            &bit_piece,
        ));
        moves.append(&mut self.get_marching_moves(
            |x| x.rotate_left(7),
            |x| bit_math::is_rank_1(x) || bit_math::is_file_a(x),
            &is_white,
            &bit_piece,
        ));
        moves.append(&mut self.get_marching_moves(
            |x| x.rotate_right(9),
            |x| bit_math::is_rank_8(x) || bit_math::is_file_a(x),
            &is_white,
            &bit_piece,
        ));
        moves.append(&mut self.get_marching_moves(
            |x| x.rotate_right(7),
            |x| bit_math::is_rank_8(x) || bit_math::is_file_h(x),
            &is_white,
            &bit_piece,
        ));

        moves
    }

    /**
     * Gets moves, assuming bit_piece is a black pawn.
     */
    fn get_black_pawn_moves(self: &Self, bit_piece: &u64) -> Vec<Move> {
        let all_bits = self.white_bits | self.black_bits;
        let mut moves = Vec::<Move>::new();

        // strictly moving move(s)
        let move_1 = bit_piece.rotate_right(8);
        if move_1 & all_bits == 0 {
            moves.push(Move::new(bit_piece, &move_1));

            if bit_math::is_rank_7(&bit_piece) {
                let move_2 = bit_piece.rotate_right(16);
                if move_2 & all_bits == 0 {
                    moves.push(Move::new(bit_piece, &move_2));
                }
            }
        }

        // strictly attacking moves
        // left attack
        if !bit_math::is_file_a(&bit_piece) {
            let left_attack = bit_piece.rotate_right(7);
            if left_attack & self.white_bits > 0 {
                moves.push(Move::new(bit_piece, &left_attack));
            }
        }
        // right attack
        if !bit_math::is_file_h(&bit_piece) {
            let right_attack = bit_piece.rotate_right(9);
            if right_attack & self.white_bits > 0 {
                moves.push(Move::new(bit_piece, &right_attack));
            }
        }

        moves
    }

    /**
     * Gets moves, assuming bit_piece is a white pawn.
     */
    fn get_white_pawn_moves(self: &Self, bit_piece: &u64) -> Vec<Move> {
        let all_bits = self.white_bits | self.black_bits;
        let mut moves = Vec::<Move>::new();

        // strictly moving move(s)
        let move_1 = bit_piece.rotate_left(8);
        if move_1 & all_bits == 0 {
            moves.push(Move::new(bit_piece, &move_1));

            if bit_math::is_rank_2(&bit_piece) {
                let move_2 = bit_piece.rotate_left(16);
                if move_2 & all_bits == 0 {
                    moves.push(Move::new(bit_piece, &move_2));
                }
            }
        }

        // strictly attacking moves
        // left attack
        if !bit_math::is_file_a(&bit_piece) {
            let left_attack = bit_piece.rotate_left(9);
            if left_attack & self.black_bits > 0 {
                moves.push(Move::new(bit_piece, &left_attack));
            }
        }
        // right attack
        if !bit_math::is_file_h(&bit_piece) {
            let right_attack = bit_piece.rotate_left(7);
            if right_attack & self.black_bits > 0 {
                moves.push(Move::new(bit_piece, &right_attack));
            }
        }

        moves
    }

    /**
     * Gets moves, assuming bit_piece is a knight.
     */
    fn get_knight_moves(self: &Self, bit_piece: &u64, is_white: &bool) -> Vec<Move> {
        let mut moves = Vec::<Move>::new();

        // precompute files
        let file_a = bit_math::is_file_a(bit_piece);
        let file_b = bit_math::is_file_b(bit_piece);
        let file_g = bit_math::is_file_g(bit_piece);
        let file_h = bit_math::is_file_h(bit_piece);

        // precompute ranks
        let rank_1 = bit_math::is_rank_1(bit_piece);
        let rank_2 = bit_math::is_rank_2(bit_piece);
        let rank_7 = bit_math::is_rank_7(bit_piece);
        let rank_8 = bit_math::is_rank_8(bit_piece);

        /* .  .  . 15  .
         * .  .  .  .  .
         * .  .  N  .  .
         * .  .  .  .  .
         * .  .  .  .  .
         */
        if !rank_7 && !rank_8 && !file_h {
            moves.append(&mut self.get_move(|x| x << 15u64, &is_white, &bit_piece));
        }

        /* .  .  .  x  .
         * .  .  .  .  6
         * .  .  N  .  .
         * .  .  .  .  .
         * .  .  .  .  .
         */
        if !rank_8 && !file_g && !file_h {
            moves.append(&mut self.get_move(|x| x << 6u64, &is_white, &bit_piece));
        }

        /* .  .  .  x  .
         * .  .  .  .  x
         * .  .  N  .  .
         * .  .  .  . 10
         * .  .  .  .  .
         */
        if !rank_1 && !file_g && !file_h {
            moves.append(&mut self.get_move(|x| x >> 10u64, &is_white, &bit_piece));
        }

        /* .  .  .  x  .
         * .  .  .  .  x
         * .  .  N  .  .
         * .  .  .  .  x
         * .  .  . 17  .
         */
        if !rank_1 && !rank_2 && !file_h {
            moves.append(&mut self.get_move(|x| x >> 17u64, &is_white, &bit_piece));
        }

        /* .  .  .  x  .
         * .  .  .  .  x
         * .  .  N  .  .
         * .  .  .  .  x
         * . 15  .  x  .
         */
        if !rank_1 && !rank_2 && !file_a {
            moves.append(&mut self.get_move(|x| x >> 15u64, &is_white, &bit_piece));
        }

        /* .  .  .  x  .
         * .  .  .  .  x
         * .  .  N  .  .
         * 6  .  .  .  x
         * .  x  .  x  .
         */
        if !rank_1 && !file_a && !file_b {
            moves.append(&mut self.get_move(|x| x >> 6u64, &is_white, &bit_piece));
        }

        /* .  .  .  x  .
         *10  .  .  .  x
         * .  .  N  .  .
         * x  .  .  .  x
         * .  x  .  x  .
         */
        if !rank_8 && !file_a && !file_b {
            moves.append(&mut self.get_move(|x| x << 10u64, &is_white, &bit_piece));
        }

        /* . 17  .  x  .
         * x  .  .  .  x
         * .  .  N  .  .
         * x  .  .  .  x
         * .  x  .  x  .
         */
        if !rank_7 && !rank_8 && !file_a {
            moves.append(&mut self.get_move(|x| x << 17u64, &is_white, &bit_piece));
        }

        moves
    }

    /**
     * Gets moves, assuming bit_piece is a king.
     */
    fn get_king_moves(self: &Self, bit_piece: &u64, is_white: &bool) -> Vec<Move> {
        let mut moves = Vec::<Move>::new();

        let file_a = bit_math::is_file_a(bit_piece);
        let file_h = bit_math::is_file_h(bit_piece);

        let rank_1 = bit_math::is_rank_1(bit_piece);
        let rank_8 = bit_math::is_rank_8(bit_piece);

        /* .  .  .
         * .  K  1
         * .  .  .
         */
        if !file_h {
            moves.append(&mut self.get_move(|x| x >> 1, &is_white, bit_piece));
        }

        /* .  .  .
         * .  K  x
         * .  .  9
         */
        if !rank_1 && !file_h {
            moves.append(&mut self.get_move(|x| x >> 9, &is_white, bit_piece));
        }

        /* .  .  .
         * .  K  x
         * .  8  x
         */
        if !rank_1 {
            moves.append(&mut self.get_move(|x| x >> 8, &is_white, bit_piece));
        }

        /* .  .  .
         * .  K  x
         * 7  x  x
         */
        if !rank_1 && !file_a {
            moves.append(&mut self.get_move(|x| x >> 7, &is_white, bit_piece));
        }

        /* .  .  .
         * 1  K  x
         * x  x  x
         */
        if !file_a {
            moves.append(&mut self.get_move(|x| x << 1, &is_white, bit_piece));
        }

        /* 9  .  .
         * x  K  x
         * x  x  x
         */
        if !rank_8 && !file_a {
            moves.append(&mut self.get_move(|x| x << 9, &is_white, bit_piece));
        }

        /* x  8  .
         * x  K  x
         * x  x  x
         */
        if !rank_8 && !file_a {
            moves.append(&mut self.get_move(|x| x << 8, &is_white, bit_piece));
        }

        /* x  x  7
         * x  K  x
         * x  x  x
         */
        if !rank_8 && !file_h {
            moves.append(&mut self.get_move(|x| x << 7, &is_white, bit_piece));
        }

        moves
    }

    /**
     * approves a move if black capturing white, white capturing black, or either capturing nothing.
     * the first bool is approval of move, second bool is whether it ends the search or not
     */
    fn approve_move(self: &Self, is_white: &bool, test_move: &u64) -> (bool, bool) {
        // either capturing nothing
        if test_move & (self.white_bits | self.black_bits) == 0 {
            return (true, true);
        }
        // capturing white, true if black, meaning not white
        if test_move & self.white_bits > 0 {
            return (!is_white, false);
        // capturing black, true if white
        } else {
            return (*is_white, false);
        }
    }

    /**
     * returns the moves that are valid when marching according to the specified bit rotate amount
     */
    fn get_marching_moves(
        self: &Self,
        shifting_fn: fn(&u64) -> u64,
        break_fn: fn(&u64) -> bool,
        is_white: &bool,
        bit_piece: &u64,
    ) -> Vec<Move> {
        let mut moves = Vec::<Move>::new();
        let mut test_move = bit_piece.clone();

        loop {
            test_move = shifting_fn(&test_move);

            // the piece looped to the row on the top
            if break_fn(&test_move) {
                break;
            }

            match self.approve_move(&is_white, &test_move) {
                (true, true) => moves.push(Move::new(bit_piece, &test_move)),
                (true, false) => {
                    moves.push(Move::new(bit_piece, &test_move));
                    break;
                }
                (false, _) => break,
            }
        }

        moves
    }

    /**
     * returns a moves if it is valid according to the specified bit rotate amount
     */
    fn get_move(
        self: &Self,
        shifting_fn: fn(&u64) -> u64,
        is_white: &bool,
        bit_piece: &u64,
    ) -> Vec<Move> {
        let mut moves = Vec::<Move>::new();
        let test_move = shifting_fn(&bit_piece);

        if self.approve_move(&is_white, &test_move).0 {
            moves.push(Move::new(bit_piece, &test_move))
        }

        moves
    }

    /**
     * gets the bit board of all the white pieces
     */
    fn update_white_bits(self: &mut Self) -> &mut Self {
        self.white_bits = self.bit_boards[white::PAWN]
            | self.bit_boards[white::KNIGHT]
            | self.bit_boards[white::BISHOP]
            | self.bit_boards[white::ROOK]
            | self.bit_boards[white::QUEEN]
            | self.bit_boards[white::KING];

        self
    }

    /**
     * gets the bit board of all the black pieces
     */
    fn update_black_bits(self: &mut Self) -> &mut Self {
        self.black_bits = self.bit_boards[black::PAWN]
            | self.bit_boards[black::KNIGHT]
            | self.bit_boards[black::BISHOP]
            | self.bit_boards[black::ROOK]
            | self.bit_boards[black::QUEEN]
            | self.bit_boards[black::KING];

        self
    }

    fn promote_pawns(self: &mut Self) -> &mut Self {
        // promote white pawns
        if self.bit_boards[white::PAWN] & board::RANK_8 > 0 {
            // add the queens to the board
            self.bit_boards[white::QUEEN] |= self.bit_boards[white::PAWN] & board::RANK_8;
            // remove the promoted pawns from the board
            self.bit_boards[white::PAWN] &= !board::RANK_8;
        }
        // promote black pawns
        if self.bit_boards[black::PAWN] & board::RANK_1 > 0 {
            // add the queens to the board
            self.bit_boards[black::QUEEN] |= self.bit_boards[black::PAWN] & board::RANK_1;
            // remove the promoted pawns from the board
            self.bit_boards[black::PAWN] &= !board::RANK_1;
        }

        self
    }

    /**
     * moves a piece based on its starting and ending position, making sure to remove any pieces it captures
     */
    fn move_piece(self: &mut Self, bit_move: Move) -> &mut Self {
        self.bit_boards = self.bit_boards.map(|bit_board| bit_board & !bit_move.end);
        self.bit_boards[self.get_index_moved(bit_move.start).unwrap()] ^=
            bit_move.start | bit_move.end;

        self.turn += 1;
        self.promote_pawns().update_black_bits().update_white_bits()
    }

    /**
     * Gets the index of the bit_board from which a piece is moving.
     */
    fn get_index_moved(self: &Self, bit_move_start: u64) -> Result<usize, NotFound> {
        for (j, bit_board) in self.bit_boards.iter().enumerate() {
            if bit_board & bit_move_start > 0 {
                return Ok(j);
            }
        }

        Err(NotFound)
    }

    pub fn print_board(self: &mut Self) -> &mut Self {
        let squares = self.get_square_array();

        println!("{}", board::TOP_BORDER);
        for rank in 0..board::RANKS {
            for layer in 0..board::LAYERS_PER_RANK {
                if layer == 0 {
                    print!(" [{}]", 8 - rank);
                } else {
                    print!(" | |");
                }
                for file in 0..board::FILES {
                    print!(
                        "{}",
                        board::PIECE[(rank + file) % 2][layer]
                            [squares[board::MAX_SQUARE_INDEX - (rank * board::FILES + file)]]
                    );
                }
                println!("| |");
            }
        }
        println!("{}", board::BOTTOM_BORDER);

        self
    }

    /**
     * Returns an array of indexes, used in printing out the board
     */
    fn get_square_array(self: &Self) -> [usize; 64] {
        let mut board = [index::EMPTY; 64];
        let mut place = 1u64;

        // goes through each of the bits and determines what piece is there
        for i in 0..u64::BITS {
            for (j, bit_board) in self.bit_boards.iter().enumerate() {
                if bit_board & place > 0 {
                    board[i as usize] = j;
                    break;
                }
            }
            place <<= 1;
        }

        board
    }
}

pub fn sample_board() -> &'static str {
    r"
.-.================================================================================================.-.
[8]::::::::::::            ::::::::::::    _ww_    ::::\++/::::            ::::::::::::            | |
| |::::UUUU::::    __,,    :::::<>:::::    \  /    ::::(  )::::     <>     ::: __,,::::    UUUU    | |
| |::::|  |::::   L   \~   :::::/\:::::    |  |    ::::|  |::::     /\     :: L   \~ ::    |  |    | |
| |::::|  |::::     ) (    ::::\  /::::    /  \    ::::/  \::::    \  /    :::: ) ( :::    |  |    | |
| |:::{____}:::   {____}   :::{____}:::   {____}   :::{____}:::   {____}   :: {____} ::   {____}   | |
[7]            ::::::::::::            ::::::::::::            ::::::::::::            ::::::::::::| |
| |            ::::::::::::            ::::::::::::            ::::::::::::            ::::::::::::| |
| |     ()     :::::():::::     ()     :::::():::::     ()     :::::():::::     ()     :::::():::::| |
| |     {}     :::::{}:::::     {}     :::::{}:::::     {}     :::::{}:::::     {}     :::::{}:::::| |
| |    {__}    ::::{__}::::    {__}    ::::{__}::::    {__}    ::::{__}::::    {__}    ::::{__}::::| |
[6]::::::::::::            ::::::::::::            ::::::::::::            ::::::::::::            | |
| |::::::::::::            ::::::::::::            ::::::::::::            ::::::::::::            | |
| |::::::::::::            ::::::::::::            ::::::::::::            ::::::::::::            | |
| |::::::::::::            ::::::::::::            ::::::::::::            ::::::::::::            | |
| |::::::::::::            ::::::::::::            ::::::::::::            ::::::::::::            | |
[5]            ::::::::::::            ::::::::::::            ::::::::::::            ::::::::::::| |
| |            ::::::::::::            ::::::::::::            ::::::::::::            ::::::::::::| |
| |            ::::::::::::            ::::::::::::            ::::::::::::            ::::::::::::| |
| |            ::::::::::::            ::::::::::::            ::::::::::::            ::::::::::::| |
| |            ::::::::::::            ::::::::::::            ::::::::::::            ::::::::::::| |
[4]::::::::::::            ::::::::::::            ::::::::::::            ::::::::::::            | |
| |::::::::::::            ::::::::::::            ::::::::::::            ::::::::::::            | |
| |::::::::::::            ::::::::::::            ::::::::::::            ::::::::::::            | |
| |::::::::::::            ::::::::::::            ::::::::::::            ::::::::::::            | |
| |::::::::::::            ::::::::::::            ::::::::::::            ::::::::::::            | |
[3]            ::::::::::::            ::::::::::::            ::::::::::::            ::::::::::::| |
| |            ::::::::::::            ::::::::::::            ::::::::::::            ::::::::::::| |
| |            ::::::::::::            ::::::::::::            ::::::::::::            ::::::::::::| |
| |            ::::::::::::            ::::::::::::            ::::::::::::            ::::::::::::| |
| |            ::::::::::::            ::::::::::::            ::::::::::::            ::::::::::::| |
[2]::::::::::::            ::::::::::::            ::::::::::::            ::::::::::::            | |
| |::::::::::::            ::::::::::::            ::::::::::::            ::::::::::::            | |
| |:::: () ::::     ()     :::: () ::::     ()     :::: () ::::     ()     :::: () ::::     ()     | |
| |:::: @@ ::::     @@     :::: @@ ::::     @@     :::: @@ ::::     @@     :::: @@ ::::     @@     | |
| |::: {@@} :::    {@@}    ::: {@@} :::    {@@}    ::: {@@} :::    {@@}    ::: {@@} :::    {@@}    | |
[1]            ::::::::::::            ::: _ww_ :::    \++/    ::::::::::::            ::::::::::::| |
| |    UUUU    ::: __,, :::     <>     ::: \@@/ :::    (@@)    :::: <> ::::    __,,    ::: UUUU :::| |
| |    |@@|    :: L@@@\~ ::     /\     ::: |@@| :::    |@@|    :::: /\ ::::   L@@@\~   ::: |@@| :::| |
| |    |@@|    :::: )@( :::    \@@/    ::: /@@\ :::    /@@\    ::: \@@/ :::     )@(    ::: |@@| :::| |
| |   {@@@@}   :: {@@@@} ::   {@@@@}   :: {@@@@} ::   {@@@@}   :: {@@@@} ::   {@@@@}   :: {@@@@} ::| |
'-'=========[a]=========[b]=========[c]=========[d]=========[e]=========[f]=========[g]=========[h]'-'"
}
